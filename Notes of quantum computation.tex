\documentclass{article}

%%% ctex package
%%%\usepackage[UTF8, scheme=plain]{ctex}
\usepackage[margin=1.2in]{geometry}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{color}
\usepackage[colorlinks=true, linkcolor=blue, anchorcolor=red, citecolor=green]{hyperref} %超链接颜色


%%%% new command

\newcommand{\ket}[1]{| #1 \rangle}  %% Dirac bra
\newcommand{\bra}[1]{\langle #1|} %%Dirac ket
\newcommand{\expec}[1]{\langle #1 \rangle} %% expectation value







\title{Quantum information and quantum computation}
\author{Xiaodi Li}
\begin{document}	
\maketitle
\tableofcontents
\newpage



\section{Classical Computation}

\subsection{Classical computation models}

\subsubsection{Turing machine}

\subsubsection{Circuit}


\subsection{Computational complexity }


\subsection{The physics of classical computation}












\newpage
\section{Quantum computation}
\textcolor{red}{Quantum computation is composed of three basic steps: preparation of the input state, implementation of the desired unitary transformation acting on input state, measurement of the output state.}
More explicitly, in order to perform a quantum computation, we should be able to:
\begin{itemize}
	\item \textit{prepare} the quantum computer in a well-defined initial state $\ket{\psi_i}$, which we call the fiducial state of the computer, for instance the state $\ket{0\cdots 0}$.
	\item \textit{manipulate} the quantum-computer wave function, that is, derive any given unitary transformation $U$, leading to $\ket{\psi_f}=U\ket{\psi_i}$;
	\item perform, at the end of the algorithm, a standard \textit{measurement} in the computational basis, that is, measure the polarization $\sigma_z$ of each qubit.
\end{itemize}
Even the evolution of the $n$-qubit system is described by $2^n\times 2^n$ unitary matrix, this matrix can be decomposed into a product of unitary operations acting only on one or two qubits. And these operations are the elementary \textit{quantum gates} of the circuit model of quantum computation.


The output of the measurement is inherently \textit{probabilistic} and the probabilities of different outputs are given by the basic laws of quantum mechanics. In a quantum algorithm, we must \textit{repeat the algorithm several times} to obtain the correct solution of our problem with probability as close to one.





\subsection{Single qubit and single qubit operations}

\subsubsection{Single qubit}
The elementary unit of quantum information and the basic building block of quantum computation is the \textit{qubit}.
A qubit is a $2$-dimensional Hilbert space. The \textcolor{blue}{pure state} of a qubit is represented by a vector 
\begin{align}
	\ket{\psi}=a\ket{0}+b\ket{1}
\end{align} 
with $|a|^2+|b|^2=1$. 
Since $\ket{\psi}\sim e^{i \phi}\ket{\psi}$, the state is described by $2$ real parameters. The state $\ket{\psi}=a\ket{0}+b\ket{1}$ can be parameterized by $a=\cos(\theta/2), b=e^{i\phi}\sin(\theta/2)$ 
\begin{align}
	\ket{\psi}= \cos(\theta/2)\ket{0} + e^{i\phi}\sin(\theta/2) \ket{1}
\end{align}
with $0\le \theta\le \pi, 0\le \phi < 2\pi$.
Then a pure state of qubit corresponds to a point $(\theta,\phi)$ on the unit sphere, which is called \textit{Bloch sphere}. The point is described by a unit $3$-vector 
\begin{align}
	(x, y, z)=(\cos\phi \sin\theta, \sin\phi \sin\theta, \cos\theta),
\end{align}
which is called the \textit{Bloch vector}.
The density operator of a generic pure state of qubit is given by 
\begin{align}
	\rho(\theta, \phi)=\ket{\psi(\theta, \rho)}\bra{\psi(\theta, \rho)}
	=\left[ \begin{array}{cc} 
		\cos^2 (\theta/2) & \sin(\theta/2) \cos(\theta/2) e^{-i\phi}\\ 
		\sin(\theta/2) \cos(\theta/2) e^{-i\phi} & \cos^2 (\theta/2)
	\end{array} \right].
\end{align}

The \textcolor{blue}{density operator} $\rho$ for the mixed state of a qubit should be $2\times 2$ Hermitian matrix and satisfies $\text{Tr}(\rho)=1$ and $\det(\rho)\ge 0$. Then $\rho$ is parameterized as
\begin{align}
	\rho = \frac{1}{2}(I+x\sigma_x+y\sigma_y+z\sigma_z)
	= \frac{1}{2} \left[ \begin{array}{cc}
		1+z & x-iy \\
		x+iy & 1-z
	\end{array} \right].	
\end{align}
Since $\det(\rho)\ge 0$, we get $\det(\rho)=\frac{1}{4}(1-x^2-y^2-z^2)\ge 0$, then $\vec{r}=(x,y,z)$ corresponds to a point on the unit ball, which is called the \textit{Bloch ball}. Pure states are located on the boundary of the Bloch ball, and the density matrix $\rho = 1/2 I$ corresponds to the centre of the Bloch ball.





\subsubsection{Single qubit operation}
Operations on a qubit are described by $2\times 2$ unitary matrices, which constitute the $\text{U}(2)$ group. For example, the Pauli matrices $\{X,Y,Z\}$, the Hadamard gate $H$, phase gate $S$, $\pi/8$ gate $T$,
\begin{align}
	& X= \left[ \begin{array}{cc} 0&1\\ 1&0 \end{array} \right],\quad 
	Y= \left[ \begin{array}{cc} 0&-i\\ i&0 \end{array} \right], \quad
	Z= \left[ \begin{array}{cc} 1&0\\ 0&-1 \end{array} \right], \\
	& H= \frac{1}{\sqrt{2}}\left[\begin{array}{cc} 1&1\\ 1&-1 \end{array} \right] , \quad
	S= \left[\begin{array}{cc} 1&0\\ 0&i \end{array} \right] ,\quad
	T= \left[\begin{array}{cc} 1&0\\ 0&e^{i \pi/4} \end{array} \right] .
\end{align}
Since $\text{U}(2)=\text{U}(1)\times \text{SU}(2)$, then for any $2\times2$ unitary matrix $U\in \text{U}(2)$, 
\begin{align}
	U=e^{i\alpha}\widetilde{U},
\end{align}
with $\widetilde{U}\in \text{SU}(2)$. 
$\text{SU}(2)$ is the double-covering group of $\text{SO}(3)$ and has the same Lie algebra as $\text{SO}(3)$, then $\widetilde{U}$ can be interpreted as a rotation transformation of a $3$-vector corresponding to a state of a qubit. $\widetilde{U}$ has two different parameterization. The first is 
\begin{align}
	\widetilde{U}=R_{\hat{n}}(\theta)= \text{exp}(-i\theta \hat{n}\cdot \vec{\sigma}/2), 
\end{align} 
where $\vec{\sigma}=(\sigma_1,\sigma_2,\sigma_3)$ are the Pauli matrices, we can interpret it as a rotation by $\theta$ around the $\hat{n}$ axis.
While the second is the Euler angle representation
\begin{align}
	\widetilde{U}=R_{z}(\beta)R_{y}(\gamma)R_{z}(\delta).
\end{align}

We get the conclusion that for any unitary operation on a single qubit, there exist real numbers $\alpha,\beta,\gamma$ and $\delta$ such that
\begin{align}
	U=e^{i\alpha} R_{z}(\beta)R_{y}(\gamma)R_{z}(\delta).
\end{align}
And there exist unitary operators $A,B,C$ on a single qubit such that $ABC=I$ and $U=e^{i\alpha}AXBXC$ with
\begin{align}
	A=R_z(\beta)R_y(\gamma/2), \quad B=R_y(-\gamma/2)R_z(-(\delta+\beta)/2), \quad C=R_z((\delta-\beta)/2).
\end{align}




\subsection{Controlled operations}

CNOT (controlled-NOT) gate is a quantum gate with two input qubits, the control qubit and target qubit. In the computational basis, the action of the CNOT is given by $\ket{c}\ket{t}\rightarrow \ket{c}\ket{c\oplus t}$. The matrix representation of CNOT is
\begin{align}
	\left[ \begin{array}{cccc} 
		1&0&0&0\\ 
		0&1&0&0\\ 
		0&0&0&1\\
		0&0&1&0\\
	\end{array} \right].
\end{align}

A controlled-U operation is a two qubit operation with a control and a target qubit. Its action is $\ket{c}\ket{t}\rightarrow \ket{c}U^c\ket{t}$.




\subsection{Universal quantum gates}

A set of gates is said to be \textit{universal} for quantum computation if any unitary operation may be approximated to arbitrary accuracy by a quantum circuit involving only those gates.

\textcolor{red}{Any unitary operation can be approximated to arbitrary accuracy using Hadamard, phase, CNOT, and $\pi/8$ gates.}
To prove the above conclusion, there are two steps.
\begin{itemize}
	\item \textcolor{blue}{Exactness}:
	
	An arbitrary unitary operator may be expressed \textit{exactly} as a product of two-level unitary operators. 
	
	An arbitrary two-level unitary operator may be expressed \textit{exactly} using only single qubit and CNOT gates.
	
	\item \textcolor{blue}{Approximation}:
	
	Single qubit operation may be approximated to \textit{arbitrary accuracy} using the Hadamard, phase, and $\pi/8$ gates.
\end{itemize}



\subsubsection{Exact realization}
There are two steps to construct the exact realization.
\begin{itemize}
	\item Two-level unitary gates are universal.
	
	Two-level unitary operators are those operators act non-trivially only on a subspace spanned by two computational basis states.
	
	\item Single qubit and CNOT gates are universal.
\end{itemize}


\subsubsection{Approximate realization}
A discrete set of gates can't be used to implement an arbitrary unitary operation exactly, since the set of unitary operations is continuous. But a discrete set can be used to approximate any unitary operation.

How to approximate unitary operators? The \textit{error} of utilizing $V$ to approximate $U$ is defined by 
\begin{align}
	E(U,V)\equiv \text{max}_{\ket{\psi}} ||(U-V)\ket{\psi}||.
\end{align}
There are two important points.
\begin{itemize}
	\item Suppose $M$ is a POVM element, and $P_U$ or $P_V$ are the probability distributions of the measurement $M$ following the action of $U$ or $V$ on a initial state $\ket{\psi}$, then
	\begin{align}
		|P_U-P_V|\le 2E(U,V).
	\end{align}


	\item If we use a sequence of gates $V_1, \cdots, V_m$ to approximate another sequence $U_1, \cdots, U_m$, the errors accumulate linearly as
	\begin{align}
		E(U_m\cdots U_1, V_m\cdots V_1) \le \sum_{j=1}^m E(U_j, V_j).
	\end{align}

\end{itemize}

There are two different sets of universal gates, the first is: Hadamard, phase, CNOT and $\pi/8$, and the second is: Hadamard, phase, CNOT and Toffoli gates. They both rely on the fact: the Hadamard and $\pi/8$ gates can be used to approximate any single qubit unitary operation to arbitrary accuracy.




\section{Quantum algorithms}

\subsection{Classical computation on a quantum computer}
A classical circuit may not be able to simulated by quantum circuits is because unitary quantum logic gates are inherently \textit{reversible}, whereas many classical logic gates such as the NAND gate are inherently \textit{irreversible}.

Any classical circuit can be replaced by an equivalent circuit containing only reversible elements by making use of the reversible gate, \textit{Toffoli gate}. The Toffoli gate can be used to simulate the NAND gate and FANOUT gates, and with these two gates it becomes possible to construct an equivalent reversible circuit.

The quantum Toffoli gate simply permute computational basis states in the same way as the classical Toffoli gate, and can be used to simulate irreversible classical logic gates just as the classical Toffoli gate. So quantum computers are capable of performing any classical computation.
It's easy for quantum computer to simulate non-deterministic classical computer.



\subsection{Quantum parallelism and Deutsch's algorithm}
Informally, quantum parallelism allows quantum computers to evaluate a function $f(x)$ for many different values of $x$ simultaneously. To implement quantum parallelism, the \textit{Hadamard transform} need to be applied to the input $n$ qubits
\begin{align}
	H^{\otimes n}:\ket{0}^{\otimes n} \rightarrow \frac{1}{2^{n/2}}\sum_x \ket{x},
\end{align}
where the sum is over all possible computational basis. The Hadamard transform produces an equal superposition of all computational basis states.

Suppose a quantum circuit apply the unitary operation to $n$ input qubit $\ket{x}$ and $1$ output qubit $\ket{y}$ as $U_f:\ket{x,y} \rightarrow \ket{x,y\oplus f(x)}$, i.e., $U_f$ evaluates the function $f(x)$. Prepare the initial state $\ket{0}^{\otimes n}\ket{0}$, apply the Hadamard transform to the first $n$ qubits, then followed by the unitary operation $U_f$, we get
\begin{align}
	\ket{0}^{\otimes n}\ket{0} \rightarrow \frac{1}{2^{n/2}}\sum_x \ket{x}\ket{0} \rightarrow \frac{1}{2^{n/2}}\sum_x \ket{x}\ket{f(x)}.
\end{align}
From above we can see that quantum parallelism enables all possible values of the function $f$ evaluated simultaneously.

However, this parallelism is not immediately useful. Since under a measurement, the final superposition state $\sum_x \ket{x, f(x)}$ will collapse into a particular state $\ket{x, f(x)}$ and give $f(x)$ for a single $x$. It requires the ability to extract information about more than one value of $f(x)$ from superposition states, in order to make quantum computation more useful.

The combination of \textit{superposition} and \textit{interference} enables quantum computation to extract some information more efficiently than classical computation.  
The Deutsch's algorithm has the following steps:
\begin{itemize}
	\item prepare the initial state $\ket{\psi_0}=\ket{01}$, 
	
	\item apply the Hadamard transform to both two qubits, $\ket{\psi_1}= H^{\otimes 2}\ket{\psi_0}= \frac{1}{2} (\ket{0}+\ket{1})(\ket{0}-\ket{1})$,
	
	\item apply the unitary operation $U_f$, $\ket{\psi_2}=U_f \ket{\psi_1}= \frac{1}{2} [(-1)^{f(0)}\ket{0}+(-1)^{f(1)}\ket{1}] (\ket{0}-\ket{1})$
	
	\item apply the Hadamard gate to the first qubit,
	\begin{align}
		\ket{\psi_3} =& \left\{ 
		\begin{array}{ccc}
			\pm \ket{0} \frac{\ket{0}-\ket{1}}{\sqrt{2}} \quad \text{if}~ f(0)=f(1) \\
															\\
			\pm \ket{1} \frac{\ket{0}-\ket{1}}{\sqrt{2}} \quad \text{if}~ f(0)\ne f(1)
		\end{array} \right.  \\
		=& \pm \ket{f(0)\oplus f(1)} \frac{\ket{0}-\ket{1}}{\sqrt{2}}.
	\end{align} 

	\item finally, make a measurement of the first qubit, we can determine $f(0)\oplus f(1)$.
\end{itemize}
The algorithm tells us that the quantum circuit has given us the ability to determine a \textit{global property} of $f(x)$ using only one evalution of $f(x)$.




\subsection{The quantum Fourier transform and its application}

\subsubsection{The quantum Fourier transform}
Discrete Fourier transformation has been defined in Appendix \ref{DFT}, and the quantum discrete Fourier transformation is defined similarly but for an set of quantum states. The \textit{quantum discrete Fourier transformation} (QDFT) is defined as a \textit{linear operator} with the action on a set of orthonormal basis $\{\ket{0}, \ket{1}, \cdots, \ket{N-1}\}$ as,
\begin{align}
	\mathcal{F}\ket{j} = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{\frac{2\pi i}{N} jk} \ket{k}. \label{QDFT_def}
\end{align}
For an arbitrary state $\ket{\psi}=\sum_{j=0}^{N-1} x_i \ket{j}$, the quantum Fourier transformation is 
\begin{align}
	\mathcal{F} \ket{\psi} = \sum_{j=0}^{N-1} x_i \mathcal{F}\ket{j} =\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \left( \sum_{j=0}^{N-1} x_i e^{\frac{2\pi i}{N} jk} \right) \ket{k} = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} y_k \ket{k},
\end{align}
where $y_k$'s are classical DFT of $x_i$'s.

To implement the QDFT in a quantum computer, we need to construct the unitary quantum circuit for QDFT. First, we consider how to represent the QDFT in the quantum computer with $n$ qubits. Let $N=2^n$, we can consider the orthonormal basis $\{\ket{0}, \ket{1}, \cdots, \ket{2^n-1}\}$ is its computational basis. For every integer $1\le j \le 2^n-1$, we can write its binary representation as 
\begin{align}
	j=j_1j_2\cdots j_n=j_12^{n-1}+\cdots+j_n2^0,
\end{align}
and a binary fraction 
\begin{align}
	0.j_lj_{l+1}\cdots j_m=j_l2^{-1}+j_{l+1}2^{-2}+\cdots + j_{m}2^{-(m-l+1)}.
\end{align}
In the binary representation, equation (\ref{QDFT_def}) becomes 
\begin{align}
	\mathcal{F}\ket{j} 
	=& \frac{1}{2^{n/2}} \sum_{k=0}^{2^n-1} e^{2\pi i 2^{-n}jk} \ket{k} \notag \\
	=& \frac{1}{2^{n/2}} \sum_{k_1=0}^{1}\cdots \sum_{k_n=0}^{1} e^{2\pi i j (\sum_{l=1}^{n}k_l2^{-l})} \ket{k_1k_2\cdots k_n} \notag \\
	=& \frac{1}{2^{n/2}} \sum_{k_1=0}^{1}\cdots \sum_{k_n=0}^{1}  \bigotimes_{l=1}^n e^{2\pi i j k_l2^{-l}} \ket{k_l} \notag \\
	=& \frac{1}{2^{n/2}} \bigotimes_{l=1}^n \sum_{k_l=0}^{1} e^{2\pi i j k_l2^{-l}} \ket{k_l} \notag \\
	=& \frac{1}{2^{n/2}} \bigotimes_{l=1}^n \sum_{k_l=0}^{1} e^{2\pi i  k_l ( 0.j_{n-l+1}\cdots j_n + j_1j_2\cdots j_{n-l})} \ket{k_l} \notag \\
	=& \frac{1}{2^{n/2}} \bigotimes_{l=1}^n \left( \ket{0} + e^{2\pi i   0.j_{n-l+1}\cdots j_n } \ket{1} \right)
\end{align}
where we have used the fact $2^{-l}j= 0.j_{n-l+1}\cdots j_n + j_1j_2\cdots j_{n-l}$.
Second, we consider constructing the quantum circuits for the QDFT. Since the transformations on every qubit are similar, we can just focus on the first qubit.
\begin{itemize}
	\item Apply the Hadamard gate, then the first qubit becomes 
	\begin{align}
		\ket{j_1} \rightarrow \frac{1}{\sqrt{2}} \left( \ket{0}+e^{2\pi i 0.j_1} \ket{1}\right).
	\end{align}

	\item Apply $j_2$-controlled-$R_2$ gate, where $R_2$ gate is
	\begin{align}
		R_2 = \left[ \begin{array}{cc} 1&0\\ 0&e^{2\pi i/2^k} \end{array} \right].
	\end{align}
	The meaning of $j_2$-controlled-$R_2$ gate is that only when $j_2=1$ then apply $R_2$ gate to the first qubit, else applying identity. So the first qubit becomes
	\begin{align}
		\ket{j_1} \rightarrow \frac{1}{\sqrt{2}} \left( \ket{0}+e^{2\pi i 0.j_1j_2} \ket{1}\right).
	\end{align}

	\item Apply the same $j_l$-controlled-$R_l$ gate until $l=n$, we get
	\begin{align}
		\ket{j_1} \rightarrow \frac{1}{\sqrt{2}} \left( \ket{0}+e^{2\pi i 0.j_1j_2\cdots j_n} \ket{1}\right).
	\end{align}

	\item Finally, apply the swap operation to transform the first qubit into last one.
\end{itemize} 
The operations for other qubits are similar, and the final step is to swap these qubits into correct order.

The first qubit needs $n$ gates, while the $l$th qubit needs $n-l+1$ gates, and the swap operations need at most $3n/2$ gates, so the total number of gates is $n+(n-1)+\cdots+1+3n/2= \frac{n(n+1)}{2}+3n/2$. Hence the circuit provides a $\Theta(n^2)$ algorithm for performing the QDFT. 

Although the implementing of QDFT is efficient, but there is no way of determining the transformed amplitudes of original states and there is in general on way to efficiently prepare the original to be transformed.




\subsubsection{Phase estimation}

Suppose a unitary operator $U$ has an eigenvector $\ket{u}$ with eigenvalue $e^{2\pi i\varphi}$, where the value of $\varphi$ is unknown. The goal of the \textit{phase estimation algorithm} is to estimate $\varphi$. 

The phase estimation algorithm consists of three parts: a \textit{black box} (or oracle) to prepare the eigenstate $\ket{u}$ and perform the controlled-$U^{2^j}$ operation for non-negative integer $j$, the \textit{first register} containing $t$ qubits initially in the state $\ket{0}$ and the \textit{second register} in the state $\ket{u}$.
There are four steps for the phase estimation algorithm.
\begin{itemize}
	\item Apply the Hadamard transformation to the first register. 
	\begin{align}
		\ket{0}^{\otimes t} \rightarrow \frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1}\ket{k}.
	\end{align}
	
	\item Apply the controlled-$U$ operations on the second register.
	\begin{align}
		\frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1}\ket{k}\ket{u} \rightarrow \frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1}\ket{k}U^{k}\ket{u}= \frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1}e^{2\pi i \varphi k} \ket{k} \ket{u} 
	\end{align}
	\item Apply the inverse Fourier transformation on the first register. If $\varphi = 0.\varphi_1\cdots \varphi_t$, then
	\begin{align}
		\frac{1}{2^{t/2}}\sum_{k=0}^{2^t-1}e^{2\pi i \varphi k} \ket{k} \ket{u} \rightarrow \ket{\varphi_1\cdots \varphi_t}\ket{u}
	\end{align}
	\item Measure the first register. Then we get the exact value of $\varphi$.
\end{itemize}
In fact, $\varphi$ can't be exactly expressed in binary representation with $t$ bits. In order to obtain $\varphi$ accurate to $n$ bits with probability at least $1-\epsilon$, we choose
\begin{align}
	t = n + \big\lceil \log(2+\frac{1}{2\epsilon}) \big\rceil.
\end{align}











\subsection{Quantum search algorithms}


\subsubsection{The quantum search algorithm}


\subsubsection{Quantum search as quantum simulation}







\subsection{Simulation of quantum systems}

\subsubsection{Simulation}
The goal of simulation is: given an initial state of the system, what is the state at some other time and or position?

Solutions are usually obtained by approximating the state with a digital representation, then discretizing the differential equation in space and time such that an
iterative application of a procedure carries the state from the initial to the final conditions.

Just simulating Schrodinger's equation is not the especial difficulty faced in simulating quantum systems. The key challenge in simulating quantum systems is the exponential number of differential equations which must be solved.

















\section{Open quantum systems}
In the real world, there are no perfect closed systems, but only open systems suffering from the unwanted interactions with the environment. These unwanted interaction show up as noise in quantum information processing systems. We need to understand and control such noise processes in order to build quantum information processing systems, so we need the mathematical description of the \textit{open quantum systems}. 
The open quantum systems are different with closed quantum systems at these points:
\begin{itemize}
	\item States are not rays in Hilber space.
	
	\item Measurements are not orthogonal projections.
	
	\item Evolution is not unitary.
\end{itemize}
To study open quantum system, we will conside the combination of the quantum system and its environment as a closed quantum system and deduce the mathematical description of the quantum system.

\subsection{States}
The Hilber space of the combination of a quantum system A and its environment B is $\mathcal{H}_{AB}=\mathcal{H_A}\otimes \mathcal{H_B}$, where $\mathcal{H}_{A, B}$ are the Hilbert spaces of A, B with the corresponding orthonormal basis being $\{ \ket{i}_A\}$ and $\{\ket{\mu}_B\}$. An arbitrary pure state of $\mathcal{H}_{AB}$ is 
\begin{align}
	\ket{\psi}_{AB}=\sum_{i,\mu} a_{i,\mu} \ket{i}_A \otimes \ket{\mu}_B,
\end{align}
then the expectation value of an observable $M_A$ of system A is
\begin{align}
	\expec{M_A} 
	=& {}_{AB}\bra{\psi} M_A\otimes I_B \ket{\psi}_{AB} \notag\\
	=& \sum_{i,j,\mu} a^*_{j \mu} a_{i, \mu} \bra{j}M_A\ket{i} \notag\\
	=& \text{Tr}(M_A \rho_A)
\end{align}
with $\rho_A$ is the \textit{density matrix} of open quantum system A obtained by taking the partial trace of $\ket{\psi}_{AB}$ over environment B
\begin{align}
	\rho_A = \text{Tr}_B(\ket{\psi}\bra{\psi}) =  \sum_{i,j,\mu} a^*_{j \mu} a_{i, \mu} \ket{i}\bra{j}.
\end{align}
So we say that: \textcolor{red}{the state of the open quantum system A is completely described by a density matrix $\rho_A$}. 
A general density matrix $\rho$ satisfies the following properties:
\begin{itemize}
	\item $\rho$ is self-adjoint: $\rho = \rho^{\dagger}$.
	\item $\rho$ is positive: for any $\ket{\psi}$, $\bra{\psi} \rho \ket{\psi} \ge 0$.
	\item $\text{Tr}(\rho) =1$.
\end{itemize}
So $\rho$ can be diagonalized in an orthonormal basis with all eigenvalues being real, nonnegative and sum to one, i.e. 
\begin{align}
	\rho = \sum_{a} p_a \ket{a} \bra{a}
\end{align}
with $0\le p_a \le 1$ and $\sum_{a} p_a =1$. We can interpret $\rho$ as describing an ensemble of pure quantum states, in which each state $\ket{a}$ occurs with probability $p_a$.

If a state is descirbed by a ray $\ket{\psi}$ in Hilber space, then the stete is \textit{pure} state, its density matrix is $\rho = \ket{\psi}\bra{\psi}$. If the state is described by a density matrix with more than one terms, then it's called \textit{mixed} state.








\subsection{Quantum measurements}

First, we discuss the meaning of measurement. Suppose we want to make a measurement of a system by the set of orthogonal porjective operators $\{E_a, a=1,\cdots,N-1\}$ with
\begin{align}
	E_a E_b = \delta_{ab}E_a, \quad E_a = E_a^{\dagger}, \quad \sum_a E_a =I.
\end{align}
We need to introduce a $N$-dimensional pointer system with fiducial orthonormal basis $\{\ket{a}, a=1,\cdots,N-1\}$, couple the system to the pointer,  and perform the unitary transformation 
\begin{align}
	U=\sum_{a,b} E_a \otimes \ket{b+a}\bra{b}.
\end{align}
If the initial state of the system and the pointer is $\ket{\Psi} = \ket{\psi} \otimes \ket{0}$, then the final state is
\begin{align}
	\ket{\Psi'}=U\ket{\Psi} = \sum_a E_a \ket{\psi}\otimes \ket{a}.
\end{align}
If the pointer is measured in the fiducial basis, the probability of obtaining outcome $a$ is
\begin{align}
	P_a = \bra{\Psi'}( I\otimes \ket{a}\bra{a} )\ket{\Psi'} = \bra{\psi} E_a \ket{\psi} = ||E_a \ket{\psi}||^2,
\end{align}
and the post-measurement state is
\begin{align}
	\frac{E_a \ket{\psi}}{||E_a \ket{\psi}||} \otimes \ket{a}.
\end{align}
Finally, if we ignore the point, then we see that the whole process provides us wth a state $\frac{E_a \ket{\psi}}{||E_a \ket{\psi}||} $ with probability $ \bra{\psi} E_a \ket{\psi} $.
So this is the real process of the measurement of a system, and we can say that: \textcolor{red}{the orthogonal measurement of the pointer in the fiducial basis induces the orthogonal measurement on the system.}





\subsection{Quantum operation}

Now we give a mathmatical definition of \textit{quantum operation}. A quantum operation $\mathcal{E}$ is a linear map from a set of density operators of Hilbert space $\mathcal{H}$ to a set of density operators of Hilber space $\mathcal{H}'$ with the following properties:
\begin{itemize}
	\item $0\le \text{Tr}[\mathcal{E}(\rho)] \le 1$.
	\item $\mathcal{E}$ is completely positive. 
\end{itemize}


\subsection{Classical noise and Markov processes}
Let $X$ denote the initial state of a bit with probability $p_0$ in state $0$ and $p_1$ in state $1$, Y is the final state of the bit with $q_0$ in state $0$ and $q_1$ in state $1$, and in the process $X\rightarrow Y$ the probability of the bit flipping is $p$, while $1-p$ for remaining the same. From the formula 
\begin{align}
	p(Y=y)=\sum_{x} p(Y=y|X=x)p(X=x),
\end{align}
where the conditional probabilities $p(Y=y|X=x)$ are called \textit{transition probabilities},
we get
\begin{align}
	\left( \begin{array}{c} q_0\\ q_1 \end{array} \right)
	= \left( \begin{array}{cc} 1-p&p\\ p&1-p \end{array} \right)
	\left( \begin{array}{c} p_0\\ p_1 \end{array} \right).
\end{align}

Making the assumption that the consecutive noise processes act independently, we can get more complicated stochastic process like $X\rightarrow Y\rightarrow Z$, which is known as \textit{Markov process}. So noise in classical systems can be described using the theory of stochastic processes, like
\begin{align}
	\vec{q}=E\vec{p} \label{classical_evolution}
\end{align}
where $E$ is a matrix of transition probabilities called the \textit{evolution matrix}. The evolution matrix must satisfy two conditions
\begin{itemize}
	\item the \textit{positivity} requirement: all entries of $E$ must be non-negative,
	\item the \textit{completeness} requirement: all columns of $E$ must sum to one.
\end{itemize}

In summary, classical noise processes are described by the Markov process, provided that the noise is caused independently by environment in each stage, and the final probabilities is generated by linear transformation of initial probabilities, described by evolution matrix.














\subsection{Quantum operations}

As the sate of a classical system is described by a vector of probabilities, a quantum system is describe by the density operator $\rho$. And similar to the evolution of a classical system as in \ref{classical_evolution}, the quantum system transform as
\begin{align}
	\rho \rightarrow \rho'=\mathcal{E}(\rho)
\end{align}
where the map $\mathcal{E}$ is called \textit{quantum operation}. Quantum operation includes the examples of unitary evolutions and measurements.

\subsubsection{Environments and quantum operations}
The way to describe the dynamics of an open quantum system is to regard the system and its environment as a closed quantum system. Suppose the system is in the state $\rho_{\text{s}}$ and the environment in $\rho_{\text{e}}$, then the initial state is $\rho_{\text{s}}\otimes \rho_{\text{e}}$. After a unitary transformation $U$, we perform a partial trace over the environment, then the quantum operation is defined as:
\begin{align}
	\mathcal{E}(\rho_{\text{s}})=\text{tr}_{\text{e}}[U(\rho_{\text{s}}\otimes \rho_{\text{e}})U^{\dagger}]. \label{quantum_operation}
\end{align}
There are two points. 
\begin{itemize}
	\item We assume that the system and the environment start in a product state.
	\item If the system has a Hilbert space of $d$ dimensions, it suffices to model the environment with a Hilber space of no more than $d^2$ dimensions.
\end{itemize}
The quantum operation can also be generalized as mapping the density operators of system $A$ to the density operators of system $B$,
\begin{align}
	\mathcal{E}(\rho_A)=\rho'_B=\text{tr}_A[U(\rho_A\otimes\rho_B)U^{\dagger}].
\end{align}

\subsubsection{Operator-sum representation}
From the definition of quantum operation (\ref{quantum_operation}), we can get the operator-sum representation. Suppose the system is in a state $\rho$, while the environment is in a pure state $\ket{e_0}\bra{e_0}$ and $\{\bra{e_k}\}$ is an orthonormal basis of the Hilbert space of the environment. Then (\ref{quantum_operation}) gives
\begin{align}
	\mathcal{E}(\rho)= \sum_k \bra{e_k}U \left(\rho\otimes \ket{e_0}\bra{e_0}\right) U^{\dagger}\ket{e_k}=\sum_k E_k\rho E_k^{\dagger} \label{operator_sum}
\end{align}
where $E_k=\bra{e_k}U\ket{e_0}$ is an operator on the state space of the system. The second equation of (\ref{operator_sum}) is known as the \textit{operator-sum representation} of $\mathcal{E}$, and the operators $\{E_k\}$ are the \textit{operation elements} of $\mathcal{E}$. 
\begin{itemize}
	\item There is another interpretation. After the unitary transformation $U$, we apply a measurement $\ket{e_k}\bra{e_k}$ of the environment and get a state of the composite system as
	\begin{align}
		\rho_k^{\text{SE}}=\frac{ \ket{e_k}\bra{e_k}U(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger} \ket{e_k}\bra{e_k}} {\text{tr}(\ket{e_k}\bra{e_k}U(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger} \ket{e_k}\bra{e_k})}
		= \frac{ \ket{e_k}\bra{e_k}U(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger} \ket{e_k}\bra{e_k}} {\text{tr}_{\text{S}}(E_k\rho E_k^{\dagger})}
	\end{align}
    with a probability 
    \begin{align}
    	p(k)= \text{tr}(\ket{e_k}\bra{e_k}U(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger} \ket{e_k}\bra{e_k})
    	= \text{tr}_{\text{S}}(E_k\rho E_k^{\dagger}).
    \end{align}
    After partial tracing the environment, we get the state of the system as
    \begin{align}
    	\rho_k^{\text{S}}=\text{tr}_{\text{E}}(\rho_k^{\text{SE}})
    	=\frac{ \text{tr}_{\text{E}}(\ket{e_k}\bra{e_k}U(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger} \ket{e_k}\bra{e_k})}{\text{tr}_{\text{S}}(E_k\rho E_k^{\dagger})}
    	=\frac{ E_k \rho E_k^{\dagger}}{\text{tr}_{\text{S}}(E_k\rho E_k^{\dagger})},
    \end{align}
    and the corresponding probability remains the same as $p(k)$. Summing up the results of all possible measurements of the environment, we get the final state of the system
    \begin{align}
    	\mathcal{E}(\rho)=\sum_k p(k) \rho_k^{\text{S}} = \sum_k E_k \rho E_k^{\dagger}.
    \end{align}
    And it's natural that the total probability equals one, i.e., 
    \begin{align}
    	1=\sum_k p(k)=\text{tr}_{\text{S}}( \sum_k E_k^{\dagger} E_k\rho ).
    \end{align}
    Since $\rho$ is arbitrary, we get the so-called \textit{completeness relation},
    \begin{align}
    	\sum_k E_k^{\dagger}E_k=1. \label{completeness}
    \end{align}


    \item The above quantum process is analogous to the classical noise process. Classical initial and final states are described by vectors of probabilities, while the quantum state of the system is described by the density operator $\rho$ or $\mathcal{E}(\rho)$. The classical state is transformed by the evolution matrix as (\ref{classical_evolution}), while the quantum state is transformed by the quantum operation as (\ref{operator_sum}).
    The classical evolution matrix satisfies the completeness relation, while the quantum operation elements also satisfy the completeness relation (\ref{completeness}). The set of quantum operation operators is called \textit{trace-preserving}, if it satisfy the completeness relation.
\end{itemize}

Quantum operation can also be used to describe the process of a measurement of the system. Suppose the system is in the state $\rho^{\text{S}}$, and the joint state of the system and the environment is $\rho^{\text{SE}}=\rho^{\text{S}}\otimes \ket{e_0}\bra{e_0}$. Then the composite system evolves by the unitary transformation $U$, after that a projective measurement $P_m$ is performed on the composite system. The final state is 
\begin{align}
	\frac{P_mU(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger}P_m}{\text{tr}(P_mU(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger}P_m)},
\end{align}
partial tracing out the environment, we get
\begin{align}
	\frac{\text{tr}_{\text{E}}(P_mU(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger}P_m)}{\text{tr}(P_mU(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger}P_m)}. 
\end{align}
So we define the quantum operation as
\begin{align}
	\mathcal{E}_m(\rho)=\text{tr}_{\text{E}}(P_mU(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger}P_m),
\end{align}
and it's operator-sum representation is
\begin{align}
	\mathcal{E}_m(\rho)
	=&\sum_{kj}\text{tr}_{\text{E}}(\ket{e_k}\bra{e_k}P_mU(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger}P_m\ket{e_j}\bra{e_j}) \notag\\
	=&\sum_k \bra{e_k}P_mU(\rho\otimes \ket{e_0}\bra{e_0})U^{\dagger}P_m\ket{e_k} \notag\\
	=& \sum_k E_k \rho E_k^{\dagger}
\end{align}
with $E_k = \bra{e_k}P_mU\ket{e_0}$.






\section{Quantum error-correction}

This chapter covers three topics: quantum error-correcting codes, fault-tolerant quantum computation, and the threshold theorem.

\subsection{Quantum error-correction code}
The key idea of error-correction codes is that we should \textit{encode} the message by adding some redundant information to the message, so even if some of the information in the encoded message is corrupted by noise, there will be enough redundancy in the encoded message to recover or \textit{decode} the message.

Consider a simple classical example, a bit is transmitted through a noisy channel, with the probability of flipping being $p$. To protect the bit, we can simply replace it by three copies of itself as
\begin{align}
	0\rightarrow 000, \quad 1\rightarrow 111.
\end{align}
We can decode the output from the channel by assuming that the output value is whatever value appears more times in the output. 
The probability that two or more of the bits are flipped is $p_e=3p^2(1-p)+p^3=3p^2-2p^3$. Then if $p<1/2$, the code is more reliable for $p<p_e$.


\subsection{Theory of quantum error-correction}

After encoding the original quantum state into a quantum error-correcting code, the code experiences a \textit{noisy process}, and then the \textit{error syndrome} and a \textit{recovery} operation are performed. We assume the noise is described by a quantum operation $\mathcal{E}$ and the complete error-correction procedure is described by quantum operation $\mathcal{R}$.












\section{Quantum computer}

\subsection{Conditions for quantum computer}

A quantum computer has to be \textit{well isolated} in order to retain its quantum properties, but at the same time its qubits have to be \textit{accessible} so that they can be manipulated to perform a computation and to read out the result.

Any physical systems suffer unwanted interactions with the outside world, called \textit{quantum noise} or \textit{decoherence}, and other different noises. A simple index can characterize these, the length of the longest possible quantum computation, which is roughly given by the ratio of $\tau_Q$ to $\tau_{op}$. $\tau_Q$ is the time for which a system remains quantum mechanically coherent, and $\tau_{op}$ is the time to perform a elementary unitary transformation.

There are four basic requirements for quantum computation.
\begin{itemize}
	\item \textcolor{blue}{Robustly represent quantum information}. A qubit is a two-dimensional Hilbert space, then it's desirable to make the physical realization of a qubit to be a two-level quantum system, at least a \textit{finite-level} quantum system. For a finite-level quantum system, it's still possible to appear decoherence for the qubit, i.e., the transitions from the superposition state of two chosen states to other unwanted states. For single qubits, the figure of merit is the \textit{minimum lifetime of arbitrary superposition states}. $T_1$, the longitudinal relaxation time of the higher energy $\ket{1}$ state, is just a classical state lifetime, while $T_2$, the transverse relaxation time of states such as $\ket{0}+\ket{1}/\sqrt{2}$ is a good measure.
	
	\item \textcolor{blue}{Prepare a fiducial initial state}. One of the most important requirements for being able to perform a useful computation is to be able to prepare the desired input. For quantum computation, it is only necessary to be able to \textit{repeatedly} produce \textit{one specific} quantum state with \textit{high fidelity}, since a unitary transformation can turn it into any other desired input state. So input state preparation is a significant problem for most physical systems. Two figures of merit are relevant to input state preparation: the \textit{minimum fidelity} with which the initial state can be prepared in a given state $\rho_{in}$, and the \textit{entropy} of $\rho_{in}$.
	
	\item \textcolor{blue}{Performance of unitary transformation}. We need to control the Hamilonian of a quantum system to realize the universal qubit gates, and we also need to require the ability to address individual qubits and to apply unitary gates to selected qubits. There are also many sources of decoherence, for example, unrecorded imperfections in unitary transformations, the cumulative effect of systematic errors, the back-action of the control system. Two figures of merit for unitary transforms are: the minimum achievable fidelity $F$ and the maximum time $t_{op}$ required to perform elementary operations.
	
	\item \textcolor{blue}{Measurement of output result}. The output from a good quantum algorithm is a superposition state which gives a useful answer with high probability when measured. There are still many difficulties. A good  figure is the signal to noise ratio.
	
	
\end{itemize}


























\appendix


\section{Complex roots of unity}
A complex $n$th root of unity is a complex number $\omega$ such that $\omega^n=1$. There are exactly $n$ complex $n$th roots of unity: 
\begin{align}
	e^{\frac{2\pi i}{n}k} \quad \text{for} \quad k = 0,1, \cdots, n-1.
\end{align}
The value $\omega_n=e^{\frac{2\pi i}{n}}$ is called the principal $n$th root of unity, then the $n$ complex roots are \begin{align}
	\{\omega_n^0, \omega_n^1, \cdots, \omega_n^{n-1}\}.
\end{align}
The $n$ complex roots of unity are equally spaced around the circle of unit radius centered at the origin of the complex plane.
There are some properties we need to note:
\begin{itemize}
	\item Cancellation lemma. For any integers $n\ge 0$, $k\ge 0$, and $d>0$, 
	\begin{align}
		\omega_{dn}^{dk} = \omega_{n}^{k}.
	\end{align}

	\item Halving lemma. If $n>0$ is even, then the squares of the $n$ complex $n$th roots of unity are the $n/2$ complex $\frac{n}{2}$th roots of unity.
	
	\item Summation lemma. For any integer $n\ge 1$ and nonzero integer $k $ not divisible by $n$, 
	\begin{align}
		\sum_{j=0}^{n-1}(\omega_n^k)^j = 0.
	\end{align}
\end{itemize}


\section{Discrete Fourier Transform} \label{DFT}

The discrete Fourier transform is an invertible, linear transformation $\mathcal{F}:\mathbb{C}^N \rightarrow \mathbb{C}^N$. For a sequence of $N$ complex numbers, $\mathcal{F}:\{x_0, x_1, \cdots, x_{N-1}\}\rightarrow \{y_0, y_1, \cdots,y_{N-1}\}$ is defined by
\begin{align}
	y_k = \sum_{n=0}^{N-1} x_n e^{-\frac{2\pi i}{N}kn}.
\end{align}
Its inverse transformation is given by
\begin{align}
	x_n = \frac{1}{N}\sum_{k=0}^{N-1} y_k e^{\frac{2\pi i}{N}kn}.
\end{align}
There are some special properties we need to note:
\begin{itemize}
	\item Orthogonality. Let $u_k$ be a vector $  (1, e^{\frac{2\pi i}{N}k},e^{\frac{2\pi i}{N}2k},\cdots,e^{\frac{2\pi i}{N}(N-1)k})^T$, then 
	\begin{align}
		u_k^T u_l^*= \sum_{n=0}^{N-1} e^{\frac{2\pi i}{N}nk}e^{-\frac{2\pi i}{N}nl}= N \delta_{kl}.
	\end{align}

	\item Parseval's theorem. Let $\{y_k\}$ and $\{w_k\}$ are the DFTs of $\{x_n\}$ and $\{z_n\}$, then
	\begin{align}
		\sum_{n=0}^{N-1}x_n z_n^* = \frac{1}{N} \sum_{k=0}^{N-1} y_k w_k^*.
	\end{align}
\end{itemize}



\end{document}
